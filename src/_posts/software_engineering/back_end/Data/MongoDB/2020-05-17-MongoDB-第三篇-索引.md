---
layout: post
title: "MongoDB 第三篇 索引"
subtitle: "MongoDB 第三篇 索引"
date: 2020-05-21 21:14:00
catalog: true
author: "tzuw"
header-img:  "img/cement.png"
tags: [MongoDB, index] 
categories: [資料倉儲]
---

索引能提高查詢效率，比如這個查詢 ```db.houses.find({price: 2000}) ```，如果沒有索引的話，就需要遍歷所有的文檔來做全表掃描。所以，一般我們會在常常需要搜尋的欄位上建立索引，來確保 MongoDB 遍歷最少的文檔就能找到結果。

```javascript
> db.houses.getIndexes()
[{
		"v" : 2,
		"key" : {
		    "_id" : 1
		},
		"name" : "_id_",
		"ns" : "five9one.houses"
}]

```

### 索引

MongoDB 允許對不同情況建立索引，例如，**Index on Single Fields, Index on Multiple Fields, Index on Embedded Fields, Index on Sub-documents** ，他們分別是對某個欄位、多個欄位、某個嵌套的欄位、某個子文檔來建立。其中，前兩個都好理解但仍需注意欄位的順序要和常用查詢的順序一致，否則無法使用到索引。而在以某個子文檔來建立索引，也需要注意欄位的順序要一致才能查詢成功。

接下來是索引的種類，**Default Indexes, Single Field Index, Compound Indexes, Multikey Indexes, Hashed Indexes, Geospatial Indexes, Text Indexes**。

```javascript
// Default Indexes 默認會為_id建立索引

// Single Field Indexes 
// 1 means descending order
> db.houses.createIndex(
    { price: 1 },
    { name: "price_index" }
)

// Compound Indexes 
// (注意查詢條件需以 price 作為前綴才可使用此索引，以 area 作為前綴是不行的)
> db.houses.createIndex(
    { price: 1, area: 1 },
    { name: "price_area_index" }
)

// Multikey Indexes 
// (當欄位的數據是數組形態時，會建立這種索引，無需其他操作。
//  並且注意不能使用兩個數組形態欄位建立此索引)
> db.houses.createIndex(
    { houses: 1 },
    { name: "houses_index" }
)

// Hashed Indexes 
// 可以做等值比較，不能比較大小，並且注意float型態可能會有異常
> db.houses.createIndex(
    { linkman: "hashed" },
    { name: "linkman_hashed_index" }
)

// Geospatial Indexes 
// 2.6v開始支持的地理坐標點欄位，該索引能提供快速搜尋附近的座標點資料的功能。
// 比如，找附近的餐廳類似的應用。$center 圓形, $box 矩形, $polygon 多邊形
> db.houses.find({
    pos: { $near: [5, 5] }
})

> db.houses.find(
    { pos: { $within: { $polygon: [[3,4],[5,7], [7,3]] } } },
    { _id: 0 }
)

// Text Indexes
// 每個 collection 只能有一個 Text Indexes
> db.houses.createIndex({
    "name": "text", 
    "linkman.name": "text", 
})

> db.houses.find({
    "$text": {
        "$search": "coffee -shop"
    }
})

```



**Unique index, Sparse index**

```db.collection.ensureIndex({ "id": 1 }, { unique: true })```，默認情況下 unique: false。當設置為 true 時代表這個欄位必須沒有重複值。```db.collection.ensureIndex({ "id": 1 }, { unique: true, dropDups: true }) })``` 這個則用來對包含重複值的欄位建立 unique 索引。



此外，Sparse Index 則是針對某欄位在一些文檔中不存在的情況建立索引。```db.houses.createIndex( { tel: 1 } , { sparse: true } )```



### Q&A

1.  字符串索引 vs. 整數做索引

    主要有兩個地方不同，第一，BSON保存的欄位類型是 NumberLong 的話，大小限制在 8 bytes。第二，範圍查詢時，字符串不會使用到正則而只是單純的比較，應該不會比較慢。

2.  字符串索引 vs.  Text Indexes 

    在某字符串欄位的一個索引，和將這個欄位作為一個 Text Indexes 有很大不同。Text Indexes 會將字符串分詞並保存成字典，相比較於只使用簡單的索引，然後加上正則規則來查詢字符，它更快。[ref](https://stackoverflow.com/questions/24316117/mongodb-difference-between-index-on-text-field-and-text-index)  [ref](https://stackoverflow.com/questions/58794422/mongodb-indexes-string-vs-int)

3.  什麼是復合索引，放在一起查詢真的會比較快嗎？

    例如，當你想將房租按照升序排列，而坪數按照降序排列 。那麼你的查詢語句可能會是 ```db.houses.find().sort(prices: 1, area: -1)```。而你就有可能會需要一個對房租和坪數的復合索引，```db.houses.createIndexes({ prices: 1, area: -1})```來加速你的排序。



延伸：

 (1) 復合索引不能有 hash indexed 類型？ [ref](https://stackoverflow.com/questions/21502216/how-to-define-a-compound-and-hashed-mongodb-index)



### 參考資料

1.  Compound Index
2.  [Geospatial Index in MongoDB](http://blog.maxkit.com.tw/2016/01/geospatial-index-in-mongodb.html)
3.  [[mongoDB]index功能的筆記](https://blog.xuite.net/flyingidea/blog/68050501-%5BmongoDB%5Dindex%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AD%86%E8%A8%98)
4.  [MongoDB Indexing (Day 13)](https://www.c-sharpcorner.com/UploadFile/f0b2ed/mongodb-day13indexing/)