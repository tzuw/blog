---
layout: post
title: "MongoDB 第五篇 資料模型"
subtitle: "MongoDB 第五篇 資料模型"
date: 2020-06-14 14:14:00
catalog: true
author: "tzuw"
header-img:  "img/cement.png"
tags: [MongoDB] 
categories: [資料倉儲]
---

MongoDB 是一個 Schema-free 的資料庫。每一筆資料的欄位型態可以不同，甚至連欄位都不一定相同，但是如果任由使用者保存，那這個資料庫其實沒有上面意義啦。因此，還是會有一些基本的設計模式。例如，One-to-One、One-to-Few、One-to-Many、One-to-Squillions，等等。

**一般在選擇設計模式的時候會根據文檔需要關聯的文檔數量做決定**，另外有時候也會考慮是否要滿足資料獨立性 ( standalone)。

### One-to-One

一對一。

### One-to-Few

一對少量。通常情況下，為了能夠一次查詢就找到文檔的所有資訊，會將文檔保存成嵌套的形態。比如，一個人對上很多個住家地址的情況就會 json 裡面的一個列表。



### One-to-Many

**Child-Referencing**。當要關聯的資料太多，**會因為一個文檔的大小不可以超過 16 MB而無法保存**時，會採用將關聯的文檔放在另一個 Collection，透過 Object ID 建立關聯的方法。不過要記得如果刪掉 child 文檔的時候要把 Parent 對應的 ObjectID 刪掉。



### One-to-Squillions

海量級。就是當使用列表保存另一個 Collection 中的 ObjectID 做關聯也會使得文檔大小超過限制的情況。這種情況就會用到 **Parent-Referencing **的方式，也就是。這種情況下一般是存放會隨著時間爆炸性成長的數據，例如日誌類型的資料。

```javascript
> db.hosts.findOne()
{
    _id : ObjectID('ABCD'),
    name : 'google.com',
    ipaddr : '127.66.66.66'
}
 
> db.logmsg.findOne()
{
    _id: ObjectID("ABCB"),    
    time : ISODate("2020-03-28T09:42:41.382Z"),
    message : 'db is on fire!',
    host: ObjectID('ABCD')       // Reference to the Host document (parent)
}
```



### Two-way Referencing

對 **Parent-Referencing **的建模的方式，我們可能會希望又子文檔查找父文檔，當然也有可能反過來，這時候就會用到雙向參照的設計來建模。



### Intermediate

**非常反正規化建模方式，重複保存了組件的 name** 。舉例而言，一個商品可能由很多個組件組成。如果我們既要**很快地**查找出商品的資訊，又要查其包含的組件的名稱，我們或許會通過 **Intermediate** 的方式來完成，如下面的例子所示。在 parts 欄位的列表中，除了保存 ObjectID 還保存了組建的名稱 name，這樣就可以通過一次查詢找到我們需要的資料。比較要注意的缺點是資料一致性的問題，如果修改了 name，就需要在其他 name 的地方也進行修改。

``` javascript
> db.products.findOne()
{
  name : '文具組',
  manufacturer : '晨光',
  catalog_number: 12345, 
  parts: [
    { id: ObjectID('AAAA'), name : '鉛筆' }, // Part name is denormalized
    { id: ObjectID('F17C'), name : '原子筆' },
    { id: ObjectID('D2AA'), name : '橡皮檫' },
    // ...
   ]
}
```



### Denormalizing from One -> Many

這又是一個非常反正規化的方式。注意，**在該欄位讀取頻率高，寫入頻率低的情況下，進行反正規化才有意義**。



### 參考資料

1.  [6 Rules of Thumb for MongoDB Schema Design: Part 1](https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-1)
2.  [MongoDB Schema 設計指南](https://blog.toright.com/posts/4483/mongodb-schema-%E8%A8%AD%E8%A8%88%E6%8C%87%E5%8D%97.html)
3.  [MongoDB Schema 設計指南 (Part II) - 反正規化的威力](https://blog.toright.com/posts/4537/mongodb-schema-%E8%A8%AD%E8%A8%88%E6%8C%87%E5%8D%97-part-ii-%E5%8F%8D%E6%AD%A3%E8%A6%8F%E5%8C%96%E7%9A%84%E5%A8%81%E5%8A%9B.html)



### 延伸閱讀

1.  https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-1
2.  [https://blog.toright.com/posts/4483/mongodb-schema-%E8%A8%AD%E8%A8%88%E6%8C%87%E5%8D%97.html](https://blog.toright.com/posts/4483/mongodb-schema-設計指南.html)
3.  https://docs.mongodb.com/stitch/mongodb/document-schemas/
4.  https://stackoverflow.com/questions/14290568/how-to-handle-mongodb-schema-change-in-production
5.  [http://mongodbcanred.blogspot.com/2015/01/mongodb.html](http://mongodbcanred.blogspot.com/2015/01/mongodb.html)  *

