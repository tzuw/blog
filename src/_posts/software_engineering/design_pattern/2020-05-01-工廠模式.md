---
title: "設計模式之工廠模式"
subtitle: "Factory Pattern"
layout: post
author: "tzuw"
date: 2020-05-01 16:22:00
tags: [学习笔记, 设计模式, 工廠模式]
categories: [软件工程]
---

工廠模式主要有三種，分別是簡單工廠模式、工廠方法模式和抽象工廠模式，挨個變得越来越複雜(~~抽象/智能/貼近業務~~)。首先，簡單工廠模式封裝了創建物件的步驟；工廠方法模式則是將物件所屬於的產品抽象出來，每種產品單獨建立一個工廠類。而抽象工廠模式則是進一步將某個一個產品族的物件的建立方法都進行封裝。簡單來說，就是一個封裝越來越多東西的演變。

### 簡單工廠模式 Simple Factory Pattern

簡單工廠模式，讓我們把 pizza 的創造和 pizza 的使用分開了，減少了 client 對於實作的依賴。**啊，對對對~ 就是分離了物件的使用和創造。調用方不再需要去處理創建物件的步驟，而只需要說明他的需求。**

當然，缺點就是，每當有新的類出現，工廠模式的類就需要修改，這塊的代碼複雜度會上升的很快。也就是簡單工廠模式違反了**開放封閉原則**。



我是分割線.jpg



### 工廠方法模式 Factory Method Pattern

於是就有另一個更強大的，（不簡單）工廠模式出現，它解決了簡單工廠模式違反的開放封閉原則。工廠方法模式，將工廠類抽象出來，讓每個產品類都有自己的工廠。具體的例子如下：

```java
// Factory.java
public interface Factory {
  public Phone createPhone();
}
```

```java
// HtcFactory.java
public class HtcFactory implements Factory {
  public Phone createPhone() {
    return new Htc();
  }
}
```

```java
// IphoneFactory.java
public class IphoneFactory implements Factory {
  public Phone createPhone() {
    return new Iphone();
  }
}
```

可以理解為，為每種產品都創建一個工廠，而這個工廠繼承至總工廠。如果想要創建一個新的產品那就要創建一個新的工廠。也就是不需要修改原有的代碼，而必須要生產一個新的工廠，這部分符合開放封閉原則。



我是分割線.jpg





### 抽象工廠模式 Abstract Factory Pattern

代工了太多種產品，每個產品都自己單獨一個工廠類，導致我們的代碼中出現了太多的工廠，很難維護耶。於是（更厲害的）**抽象工廠模式**，就出現了。這個模式能夠在不違反開放封閉原則的條件下，又能夠降低增加新產品時所增加的複雜度。

抽象工廠，指的是定義一個創建產品族的介面，產品族裡面每個產品的具體類別由繼承抽象工廠的實體工廠決定。它的目的是為了能**建立一系列相關或互相依賴物件的介面，而無需指定它們具體的類別**。

舉例而言，披薩的原料有麵團、醬料和起司，而因為不同地區人的口味不同，台灣的比薩店和美國的比薩店用的這些原料的製作方式並不相同。於是，你的披薩店在抽象工廠模式下，就需要實作一個披薩原料製作的介面，我們可以叫它 PizzaIngredientFactory。

PizzaIngredientFactory 工廠按照上面所說的進行抽象，每個地域創建一個，如此就可以達到抽象工廠的目的，"**建立一系列相關或互相依賴物件的介面，而無需指定它們具體的類別**"了。



```java
public class CheesePizza extends Pizza {
    PizzaIngredientFactory = ingredientFactory;
    public CheesePizza(PizzaIngredientFactory ingredientFactory){
      	this.ingredientFactory = ingredientFactory;
    }
    void prepare() { // 這邊將原料抽出來讓工廠 各地域的原料工廠維護
    	  dough = ingredientFactory.createDough();
        sauce = ingredientFactory.createSauce();
     		cheese = ingredientFactory.createCheese();
    }
}

public class NYPizzaStore extends PizzaStore {
 	 protected Pizza createPizza(String item) {
 	 		Pizza pizza = null;
 	 	  PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();
 	 	  if (item.equals("cheese")) { 
	     	 pizza = new CheesePizza(ingredientFactory);
 		  } else if (item.equals("veggie")) {
	    	  pizza = new VeggiePizza(ingredientFactory);
	    } else if (item.equals("clam")) {
	   	   pizza = new ClamPizza(ingredientFactory);
	    } else if (item.equals("pepperoni")) {
	   	   pizza = new PepperoniPizza(ingredientFactory);   
	    } 
	    return pizza;
	 }
}


PizzaStore nyStore = new NYPizzaStore();
Pizza pizza = nyStore.orderPizza("cheese");

```



### 參考資料

1.  [https://blog.techbridge.cc/2017/05/22/factory-method-and-abstract-factory/](https://blog.techbridge.cc/2017/05/22/factory-method-and-abstract-factory/)



### 延伸閱讀

1.  [https://blog.amowu.com/2009/08/factory-pattern.html](https://blog.amowu.com/2009/08/factory-pattern.html ) 

    最後面有介紹Java的反射機制的結合，Reflection (反射) 指可以依照 class 的名稱來實體化類別。

  