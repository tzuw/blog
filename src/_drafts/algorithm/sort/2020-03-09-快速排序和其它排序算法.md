---
title: "快速排序和其它排序算法"
subtitle: "Quick Sort and others"
layout: post
author: "tzuw"
date: 2020-03-10 16:22:00
tags: [排序算法, 快速排序, 学习笔记]
categories: [算法]
---

###  快速排序的两种简单实现

>   Quick Sort

```java
public class Solution {
  public static void quickSort(int[] arr, int left, int right) {
    if (left < right) {
      int p = partition(arr, left, right);
      quickSort(arr, left, p - 1);
      quickSort(arr, p + 1, right);
    }
  }
  
  public static int partition1(int[] arr, int left, int right) {
    int pivotIndex = left + (right - left)/2;
    int pivot = arr[pivotIndex]; 
    int temp; // swap pivot value to right for preserving
    temp = arr[right];
    arr[right] = arr[pivotIndex];
    arr[pivotIndex] = temp;
    
    for (int i = left, j = left; j < right; j++) { // 1 2 3 4 5 5 6 
      if (arr[j] <= pivot) { // 找一个比 pivot 大的数，下标 = i 。
        if (arr[j] != arr[i]) { 
          temp = arr[j];
          arr[j] = arr[i];
          arr[j] = temp;          
        }
        i++;
      }
    }
    temp = arr[i];
    arr[i] = arr[right]; // 和原始的 pivot 位置(已被right替换)交换
    arr[right] = temp;
    return i;
  }
  
  public static int partition2(int[] arr, int left, int right) {
		Random random = new Random();
		int pivotIndex = left + random.nextInt(right - left + 1);
    // int pivotIndex = left + (right - left) / 2;
    // System.out.println(" " + left + " " + right + " " + pivotIndex);
    int pivot = arr[pivotIndex];
    int temp;
    temp = arr[right];
    arr[right] = arr[pivotIndex];
    arr[pivotIndex] = temp;
    
    int i = left, j = right;
    while (i < j) {
      while (arr[i] <= pivot) {
        i++;
      }
      while (arr[j] >= pivot) {
        j--;
      }
      temp = arr[i];
      arr[i] = arr[j];
      arr[j] = arr[i];
    }
    temp = arr[i];
    arr[i] = arr[right];
    arr[right] = arr[i];
    return i;
  }
}
```

**p.s 需要注意的地方 : **

1.  **快速排序的思想：分治法**

    每次把数组切分成两部分，大于 pivot 的部分和小于 pivot 的部分。

    

2.  **临界点的地方**

    ```java
    // 第一种
    for (int i = left, j = right; i < right; j++) {
      ...
    }
    
    // 第二种
    int i = left, j = right;
    while (i < j) {
      ...
    }
    
    ```

    比如，数组 [ 1, 100, 2, 40, 11, 5, 1, 18, 10 ]，

    在遇到临界点 [ ~~1, 1, 2, 5, 10, 11, 18~~, 40, 100 ]  的时候，还需要对剩下的部分进行排序。

    此时，left = 7，right  = 8，在两种实现方式中，都是把相邻的 left 和 right 输入，然后**根据条件确认需要互换的位置**。最后，出循环并执行互换。

    **条件**：

    (1) 从前往后遍历，如果遇到小于等于 pivot 的位置，就把 i++，即将需要互换的位置往后挪一位；

    (2) 两头往中间遍历，前面和条件一一样，从后往前的遍历则是，如果遇到大于等于 pivot 的位置，就把 j-- ，即将需要互换的位置往前挪一位；

    

3.  **随机 pivot 有什么好处？**

    

4.  **两种实现方式的区别？**

    一个只从前面开始往后面找，第二个从两头往中间找。

    

5.  **时间复杂度怎么解释？**

    

6.  **还有什么其他改进的地方？**



### 其它排序算法

排序算法可以分为 2 种，非线性时间比较类和线性时间非比较类。

**基于比较：**(非线性时间) 

*基于比较的排序算法不能突破 O(nlogn)*

-   交换类排序：冒泡排序、快速排序。
-   插入类排序：插入排序、希尔排序。
-   选择类排序：选择排序、堆排序。
-   归并排序：二路归并排序。

>   注意数据初始排序状态对堆排序没有太大的影响，但是快速排序却恰恰相反。
>
>   若是一个完全倒序的数组，那么快排的最差时间复杂度等于 O(N^2)。



**非基于比较**： (线性时间)

-   计数排序
-   基数排序
-   桶排序

>   其中，**计数排序**要求待排序数的最大值不能太大；**桶排序**要求元素按照hash分桶后桶内元素的数量要均匀。
>
>   线性时间非比较类排序的典型特点是以空间换时间



---



##### 1.冒泡排序

>   Bubble Sort

```java
public class BubbleSort { // 3 7 2 5 8 -1
  public static void sort(int[] arr) {
    int temp;
    for (int i = 0; i < arr.length; i++) {
      for (int j = 1; j < arr.length - 1; j++) {
        if (arr[j-1] > arr[j]) {
          temp = arr[j];
          arr[j] = arr[j - 1];
          arr[j - 1] = temp;
        }
      }
    }
  }
}
// 可以改进的地方：
//
```



##### 2.插入排序

>   Insertion Sort

```java
// 将某个值插入到数组中已经排好序的部分
public class InsertionSort {
  public static void sort(int[] arr) {
    int temp;
    for (int i = 1; i < arr.length; i++) {
      temp = arr[i];
      for (int j = i; j > 0 && arr[j - 1] > temp; j--) {
        arr[j] = arr[j - 1];
      }
      arr[j] = temp;
    }
  }
}
```



##### 3.希尔排序

>   Shell Sort   时间复杂度 **O(N^ 3/2)**

*wik: 希尔排序(Shell's Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。 希尔排序是非稳定排序算法。 该方法因D.L.Shell于1959年提出而得名。*

以某个增量将数组划分为若干组，然后分组进行插入排序。逐步缩小增量，直到增量为 1 都进行插入排序。



一般而言，增量序列设定为 {n/2, (n/2)/2, ..., 1} (希尔增量)，其最坏时间复杂度依然为O(N^ 2)。

一些经过优化的增量序列如 Hibbard ，经过复杂证明可使得最坏时间复杂度优化至 O(N^ 3/2)。

```java
// 3 7 8 '5' 2 -1, div=3, [3, 5], [7, 2], [8, -1]
// div=1, [3], [5], [2], [7], [-1], [8]
public class ShellSort {
  public static void sort(int[] arr) {
    int temp;
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
      for (int k = 0; k < gap; k++) { // k 个分组
        // 遍历每个分组内的元素，比如 [3, 5]
        // [3, [5]]，5 和前面的元素 3 比较，然后进行互换，或者找到合适的位置向后平移
        for (int i = gap + k; i < arr.length; i += gap) {
          for (int j = i - gap; j >= k; j -= gap) {
            if (arr[j + gap] < arr[j]) {
              temp = arr[j + gap];
              arr[j] = arr[j + gap];
              arr[j + gap] = arr[j];
            }
          }
        }
      }
    }
  } 
}
// 很多语言的实现版本 
// https://openhome.cc/Gossip/AlgorithmGossip/ShellSort.htm#Java
```



##### 4.归并排序

>   Merge Sort  **)和快速排序一样使用了分治法**

```java
// 首先想到的是，时间复杂度为O(nlgn),空间复杂度为O(n).
public class MergeSort {
  public static void sort(int[] arr, int[] tmp, int left, int right) {
    if (left < right) {
      int mid = left + (right - left) / 2;
      sort(arr, tmp, left, mid);
      sort(arr, tmp, mid + 1, right);
      merge(arr, tmp, left, mid, mid + 1, right);
    }
  }
  
  public static void merge(int[] arr, int left0, int right0, int left1, int right1) {
    int i = left0, j = left1, k = left0;
    while (i <= right0 && j <= right1) {
      if (arr[i] <= arr[j]) {
        tmp[k++] = arr[i++];
      } else {
        tmp[k++] = arr[j++];
      }      
    }
    while (i <= right0) {
      tmp[k++] = arr[i++];
    }
    while (j <= tight1) {
      tmp[k++] = arr[j++];
    }
    for (int c = left0; c < right1 - left0 + 1; c++) {
      arr[c] = tmp[c];
    }
  }
  
  public static void main(String[] args) {
    int[] arr = new int[]{3, 7, 2, 5, 8, -1};
    int[] tmp = new int[arr.length];
    sort(arr, tmp, 0, arr.length - 1);
    for (int i = 0; i < arr.length; i++) {
      System.out.print(arr[i] + " ");
    }
    System.out.println();
  }
}
```

**Mark** 

上面归并排序的 merge 方法时间复杂度的最差情况是 O(N^2) 的解法。

*Knuth left as an exercise ...* ，要求一个 merge 时间复杂度是 O(N)，空间复杂度 O(1) 的解法。ref: [[1]](https://www.cnblogs.com/daniagger/archive/2012/07/25/2608373.html), [[2]](https://stackoverflow.com/questions/2571049/how-to-sort-in-place-using-the-merge-sort-algorithm) 。（戏称为，原地归并排序）



##### 5.计数排序

>   Counting Sort  时间复杂度 O(N+K) ，空间复杂度 O(K)。

-   方法：

    (1) 将输入的数据值和其出现次数，存储成键值对保存在额外的数组空间;

    (2)  

-   作为一种空间换时间的方法，计数排序要求输入的**整数数组**有确定范围。（它并**不适合数据范围很大的数组**，会造成很大的空间和时间开销）
-   计数排序的稳定性是它的重要特性。



```java
public class CountingSort {
  // 不稳定的方法
  public static void sort(int[] arr, int min, int max) {
    int[] counts = new int[max - min + 1]; // k个不重复整数
    for (int num : arr) {
      counts[num - min] += 1;
    }
    int count, ix = 0; // n 笔数据
    for (int i = 0; i < counts.length; i++) { 
      count = counts[i];
      for (int j = 0; j < count; j++) {
        arr[ix] = min + i;
        ix++;
      }
    }
  }
  
  // 稳定的方法
  // min=0, max=10, len(arr)=8
  // result, order are empty arrays of the same length with arr
  // , where order represent element in result comes from which arr (index).
  // original sample: [ 3 5 10 9 1 0 3 4 ]
  // 1st forloop, conuts = [ 1 1 0 2 1 1 0 0 0 1 1 ]
  // 2rd forloop, conuts = [ 0 1 1 3 4 5 5 5 5 6 7 ]
  // the result should be [ 0 1 3 3 4 5 9 10 ]
  // the orders should be [ 2 5 7 6 1 0 3 4 ]
  public static void sort(int[] arr, int[] result, int[] orders, int min, int max) {
    int[] counts = new int[max - min + 1];
    for (int num : arr) {
      counts[num - min] += 1;
    }
    for (int i = 1; i < counts.length + 1; i++) {
      counts[i] += counts[i-1]; // 这是每个位置所代表的数的 order
    }
    for (i = arr.length - 1; i >= 0; i--) {
      result[ counts[arr[i]] ] = arr[i]; // 数组最后一个数字在结果中的第几位
      orders[ counts[arr[i]] ] = i; 
      counts[ arr[i] ]--; // 并且，从 order 上也可以发现第一个3的index在第二个3之前，是稳定的
    }
  }
}
```



##### 6.桶排序

>   Bucket Sort

*又快又简单的方法*，时间复杂度 O(N+ K)，空间复杂度O(N+ K)。

```java
// 一种特殊的情况
其实就是上面的不稳定的计数排序
```





##### 7.基数排序

>   Radix Sort

*将整数按位数切割成不同的数字，然后按每个位数分别比较。*

*由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。*

是一种可以根据多个键值来排序的方法。

用一个例子来记忆：

```
原数组
索引    0   1   2   3   4   5   6   7   8   9
数值   69  81  30  38   9   2  47  61  32  179

首先，拿个位数的值进行计数排序：

索引    0   1   2   3   4   5   6   7   8   9
数值   69  81  30  38   9   2  47  61  32  179
个位    9   1   0   8   9   2   7   1   2   9

索引    0   1   2   3   4   5   6   7   8   9
數值   30  81  61   0  32  47  38  69   0  179
       0   1   1   2   2   7   8   9   9   9

--- 个位数排完，排十位数 ---

索引    0   1   2   3   4   5   6   7   8   9
數值   30  81  61   0  32  47  38  69   0  179
百位    0   0   0   0   0   0   0   0   0   1
十位    3   8   6   0   3   4   3   6   0   7
> 个位    0   1   1   2   2   7   8   9   9   9


索引    0   1   2   3   4   5   6   7   8   9
百位    0   0   0   0   0   0   0   0   1   0
> 十位    0   0   3   3   3   4   6   6   7   8
个位    2   9   0   2   8   7   1   9   9   1

--- 十位数排完，排百位数 ---


然后就排完了

```



##### 8.选择排序

>   Selection Sort

```java
// 每次找一个最小值
public class SelectionSort {
  public static void sort(int[] arr) {
    int minIndex = 0, temp;
    for (int i = 0; i < arr.length; i++) {
      minIndex = i; // 每次寻找最小值的起点
      for (int j = i; j < arr.length; j++) {
        if (arr[j] < arr[minIndex]) {
          minIndex = j;
        }
      }
      temp = arr[minIndex];
      arr[i] = arr[minIndex];
      arr[minIndex] = temp;
    }
  }
}
```



##### 9.堆排序

>   Heap Sort





### 时间复杂度总结

![](/public/assets/img/in-post/sort-algorithms-1.png)



### 参考资料

1.  [https://www.cnblogs.com/chengxiao/p/6104371.html](https://www.cnblogs.com/chengxiao/p/6104371.html)

    希尔排序

2.  [https://openhome.cc/Gossip/AlgorithmGossip/ShellSort.htm#Java](https://openhome.cc/Gossip/AlgorithmGossip/ShellSort.htm#Java)

3.  [https://blog.csdn.net/jnu_simba/article/details/9705111](https://blog.csdn.net/jnu_simba/article/details/9705111)

    十种排序算法总结，包含桶排序、基数排序、计数排序的 C++ 实现。

4.  [**https://www.cnblogs.com/onepixel/p/7674659.html**](https://www.cnblogs.com/onepixel/p/7674659.html)

    十大经典排序算法（动图演示）

5.  [https://magiclen.org/counting-sort/](https://magiclen.org/counting-sort/)

    计数排序法，稳定 && 不稳定。

6.  [https://www.byvoid.com/zht/blog/sort-radix](https://www.byvoid.com/zht/blog/sort-radix)

    神人