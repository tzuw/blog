---
layout: post
title: "字符串包含关系"
subtitle: "How to check if one string contains another ?"
date: 2020-03-07 13:10:00
author: "tzuw"
header-img: "public/assets/img/cement.png"
tags: [String, Java, 学习笔记] 
categories: [算法]
---

### 题目	

给两个字符串，长度分别为m和n，并且m>n，判断其中一个字符串中的字母是不是都可以在另一个字符串中找到。

### 题解

比较容易想到的解法是，拿一个字符串中的字母去另一个字符串中挨个遍历，时间复杂度是O(m*n)。

当然既然有遍历查找的操作，就能在允许的情况下将字符串中的字母进行排序，如此就可以按照二分查找的套路，把查找的复杂度降低到 O(lgn)。整体的时间复杂度也就下降为 O(mlgm)。用代码演示如下：

```java
import java.util.Random;

public class StringContains {
  public static void main(String[] args) {
    String a = "faffad";
    String b = "dafde";
    char[] c = a.toCharArray();
    char[] d = b.toCharArray();
    quickSort(c, 0, c.length - 1);
    quickSort(d, 0, d.length - 1);
    System.out.println(strContain(c, d));
  }

  public static boolean strContain(char[] a, char[] b) {
    boolean aContainsB = false;
    // for (char i : a) {
    //    System.out.print(i);
    // }
    // System.out.println();
    // for (char i : b) {
    //    System.out.print(i);
    // }
    // System.out.println();
    for (int i = 0; i < a.length; i++) {
      aContainsB = binarySearch(a, b[i]);
      if (!aContainsB) {
        System.out.println(b[i]);
        return false;
      }
    }
    return true;
  }

  public static void quickSort(char[] arr, int left, int right) {
    if (left < right) {
      int p = partition(arr, left, right);
      quickSort(arr, left, p-1);
      quickSort(arr, p+1, right);
    }
  }

  public static int partition(char[] arr, int left, int right) {
    Random random = new Random();
    int pivotIndex = left + random.nextInt(right - left + 1);
    char pivot = arr[pivotIndex];
    swap(arr, pivotIndex, right);
    
    int swapIndex = left - 1;
    for (int j = left; j < right; j++)  // 1 2 3 4 5 5 6
      if (arr[j] <= pivot) {
        swapIndex++;
        swap(arr, swapIndex, j);
      }
    }
    swapIndex++;
    swap(arr, swapIndex, right);
    return swapIndex;
  }

  private static void swap(char[] array, int ix, int iy) {
    char temp;
    temp = array[ix];
    array[ix] = array[iy];
    array[iy] = temp;
  }

  public static boolean binarySearch(char[] arr, char target) {
    int left = 0;
    int right = arr.length - 1;
    while (left < right) {
      // int mid = left + (right - left) / 2;
      // int mid = (left + right) / 2; 问题记录
      if (arr[mid] < target) {
        left = mid + 1;
      } else if (arr[mid] > target) {
        right = mid - 1;
      } else {
        return true;
      }
    }
    if (arr[left] == target) {
      return true;
    }
    return false;
  }
}
```

当然，倘若你同时遍历两个字符串，时间复杂度就会变成 ( O(m log m) + O(n log n) )+ O(m+n) ，前面是排序所需的时间，后面是同时扫描两个字符串所需要的时间。

```java
public class StringContains {
  public static void main(String[] args) {
    String a = "aaadf";
    String b = "dddddf";
    char[] c = a.toCharArray();
    char[] d = b.toCharArray();
    quickSort(c, 0, c.length - 1);
    quickSort(d, 0, d.length - 1);
    System.out.println(strContain1(c, d));
  }
  public static boolean strContain1(char[] a, char[] b) { // 扫描
    int i, j;
    for (i=0, j=0; i<a.length; i++) {
      while (j<b.length-1 && a[i]>=b[j]) {
        j++;
      }
    }
    if (j<b.length-1 || a[a.length-1]<b[j]) { // b没有遍历完 || a的最后一个小于b的
      return false;
    }
    return true;
  }
}
```

### 问题记录

二分搜寻计算中点时，right + (left - right)/2 和 (left + right)/2 不相等，会造成left=0, right=1时异常。

https://stackoverflow.com/questions/27167943/why-leftright-left-2-will-not-overflow

### 参考资料

编程之法：面试和算法心得

