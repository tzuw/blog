---
title: "二叉树的遍历"
subtitle: "Traversing Binary Trees."
layout: post
catalog: true
author: "tzuw"
date: 2020-03-10 16:22:00
istodo: true
tags: [binary tree traversal, leetcode, 刷题, 学习笔记]
categories: [算法]
---

递归会造成一些多余的内存空间的浪费（每次调用函数都会在栈中创建栈帧，需要保存参数）。使用非递归的方法进行二叉树的遍历稍微有些麻烦，但是相对地也节约了内存空间，也是笔试/面试中经常考的。

很重要所以要说三遍。

### 前序遍历

> Pre-order Traversal

```java
public class PreOrder {
  public void traverse(Tree tree) {
    if (tree == null) {
      return;
    }
    System.out.print(tree.val + " ");
    traverse(tree.left);
    traverse(tree.right);
  }
}
```



### 中序遍历

>   In-order Traversal

```java
public class InOrder {
  public void traverse(Tree tree) {
    if (tree == null) {
      return;
    }
    traverse(tree.left);
    System.out.print(tree.val + " ");
    traverse(tree.right);
  }
}
```



### 后序遍历

>   Post-order Traversal

```java
public class PostOrder {
  public void traverse(Tree tree) {
    if (tree == null) {
      return;
    }
    traverse(tree.left);
    traverse(tree.right);
    System.out.print(tree.val + " ");
  }
}
```



### 层序遍历

>   Level-order Traversal

```java
     1
    / \
   2   3
    \
     4
       
// the key is to maintain Binary tree level while traversal
public class InOrder {
  public void traverse(Tree tree, int level, ArrayList<ArrayList<int>> result) {
    if (tree == null) {
      return;
    }
    if (result.length() - 1 < level) {
      result[i] = new ArrayList<int>();
    }
    result[level].add(tree.val);
    traverse(tree.left, level + 1, result);
    traverse(tree.right, level + 1, result);
  }
  
  public static void main(Stirng[] args) {
    Tree root = getSample(); // get samples
    ArrayList<ArrayList<int>> result = new ArrayList<>();
    traverse(root, 0, result);
  }
}
```



### 非递归的方式

>The non-recursive (iteration) way

暴力，暴力，暴力的先说结论：「除了层序遍历不用栈 (stack) 而是用队列 (queue) 来实现，前序遍历、中序遍历和后序遍历都**可以**借助栈 (stack) 来实现。」



### 非递归前序遍历

>   前序遍历
>
>   & store element of every level in an ArrayList ( in order to solve leetcode 102 in a stupid way ...  )

```java
     1
    / \
   2   3
    \
     4
// 
// res = [ [1], [2, 3], [4] ] 
public class PreOrderWithoutRecursion {
  public static List<List<Integer>> traverse(Tree tree) {
    Stack<Tree> stack = new Stack(); // push 入栈, pop 出栈, peek 栈顶
    List<List<Integer>> res = new ArrayList<>();
    for (int c=0; c<tree.getHeight(); c++) {
      res.add(new ArrayList<Integer>());
    }
    Tree node = tree;
    Tree lastVisited = null;
    // int i = -1;
    while (!stack.isEmpty() || node != null) {
      if (node != null) {
        stack.push(node);
        // res.get(++i).add(node.val);
        node = node.left;
      } else {
        node = stack.peek();
        if (node.right == null || lastVisited == node.right) {
          stack.pop();
          lastVisited = node;
          node = null;
          // i--;        
        } else {
          node = node.right;
        }
      }
    }
    return res;
  }
}
```

 // 擦 牛逼了 stack 都不用 pop 的

1.  要如何在遍历的时候知道在二叉树的第几层？

一路遍历边输出到最底，然后挨个上来的时候看有没右节点。。



### 非递归中序遍历

>   锻炼的是思维能力

```java
     1
    / \
   2   3
  / \
 5   4

// 
// 
// res = [5, 2, 4, 1, 3]
public class InOrderWithoutRecursion {
  public static void traverse(Tree tree, ArrayList<Integer> result) {
    if (tree == null)	return;
    Stack<Tree> stack = new Stack(); // push, pop, peek
    Tree node = tree;
    while (!stack.isEmpty() || node == null)) {
      while (node != null) {
        stack.push(node); // 在这里 push 右子节点，你敢信。。一开始就想错了
        node = node.left;
      }
      if (!stack.isEmpty()) {
        node = stack.peek();
        result.add(node.val);
        node = node.right; // 这行。。？
        stack.pop();
      }
    }
    return result;
  }
}
```

**Mark**:

-    在思考的时候，从根头节点**遍历到左子树最远的叶节点**时，只考虑了左子节点的情况；

    只考虑左子节点是不可能**遍历到左子树最远的叶节点**的，所以，一定会有一行是: node = node.right; 否则，完全无法遍历到二叉树的最远的地方；

-   成功非递归实现中序遍历的关键是：

    -   出栈的条件：该节点位于 stack 的顶部，且出栈前确保它的左子节点已遍历 (或没有左子节点) ；
    -   自实现递归

-   ” !stack.isEmpty() “ 判断条件重复的部分；这是因为在出栈的时候，判断了 stack 是否为空，但是其实在前面就判断了，所以应该可以改良变得更简洁；

    -   为什么不能在一开始就想到简洁的写法？

        node != null && stack.isEmpty() 的情况不会出现，因为 node != null 时 push 了；

        

```java
     1
    / \
   2   3
  / \
 5   4
       
// 只给出关键的部分
while (!stack.isEmpty() || node == null)) {
  if (node != null) {
    stack.push(node);
    node = node.left;
  }
  else {
    node = stack.peek();
    stack.pop();
    result.add(node.val); // 出栈的条件
    
    node = node.right; // 自实现递归的关键
  }
}

```



### 非递归后序遍历

>   *需要判断上次访问的节点是位于左子树，还是右子树。若是位于左子树，则需跳过根节点，先进入右子树，再回头访问根节点；若是位于右子树，则直接访问根节点。* [[1]](https://blog.csdn.net/zhangxiangDavaid/article/details/37115355)

```java
     1
    / \
   2   3
  / \
 5   4

// 
// 
// res = [ 5, 4, 2, 3, 1 ]
public class PostOrderWithoutRecursion {
  public static void traverse(Tree tree, ArrayList<Integer> result) {
    Stack<Tree> stack = new Stack();
    Tree node = tree;
    Tree lastVisited = null; // 標誌出 node.right 是否被訪問過
    while (node != null) {
      stack.push(node);
      node = node.left;
    }
    while (!stack.isEmpty()) {
      node = stack.peek();
      if (node.right == null || lastVisited == node.right) {
        result.add(node.val);
        lastVisited = node;
        stack.pop();
      } else {
        // else if (node.left == pLastVisit) {
        node = node.right;
        while (node) {
          stack.push(node);
          node = node.right;
        }
      }
    }
}
```

**Mark**

1.  成功实现的条件
    -   子节点均遍历方可出栈；
    -   非递归 (迭代) 的方式模拟递归遍历；
    -   想好在下笔；**实在太难写了ORZ**
2.  和非递归中序遍历不一样的地方只有？

### 非递归层序遍历

[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

应该用 Queue 会比较方便，我头脑发热用 Stack 写了 (就是本文上面的非递归前序遍历的地方，就当锻炼思维了。。) 。Stack 的运行时间明显没有队列快。

```java
     1
    / \
   2   3
  / \
 5   4

// res = [ [1], [2, 3], [5, 4] ]
// Using one queue
public class LevelOrderWithoutRecursion {
  public static List<List<Integer>> traverse(Tree tree) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
      return result;
    }
    TreeNode node = tree;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(tree);
    while (!queue.isEmpty()) {
      ArrayList<Integer> sub = new ArrayList<>();
      int size = queue.size();
      for (int i = 0; i < size; i++) {
        node = queue.peek();
        queue.poll();
        sub.add(node.val);
        if (node.left != null)	queue.offer(node.left);
        if (node.right != null)	queue.offer(node.right);
      }
      result.add(sub);
    }
    return result;
  }
}
```





### Remark

栈，又称为堆栈，是一种先进后出的线性表。[[传送门]](https://blog.csdn.net/javazejian/article/details/53362993)

>   Stack



队列，是一种先进先出的线性表。

>   Queue



堆，又称为堆积 (Heap)，通常可以被看做是一棵树的数组形象。它总是满足的特性有：(1) 堆中某个节点的值总是不大于或不小于其父节点的值；(2) 堆总是一棵完全二叉树；

>   Heap



### 参考资料

1.  [https://blog.csdn.net/zhangxiangDavaid/article/details/37115355](https://blog.csdn.net/zhangxiangDavaid/article/details/37115355) 

    递归的自我实现，node = node.right;

2.  https://blog.csdn.net/javazejian/article/details/53362993

3.  [https://stackoverflow.com/questions/19880185/java-initialize-2d-arraylist](https://stackoverflow.com/questions/19880185/java-initialize-2d-arraylist)

    initialize 2d ArrayList in Java.

