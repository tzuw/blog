---
title: "二叉树"
subtitle: "Binary tree"
layout: post
author: "tzuw"
date: 2020-03-11 16:22:00
istodo: true
tags: [二叉树, leetcode, printBinaryTree, 学习笔记, 刷题, ]
categories: [算法]
---

### 打印二叉树

>   本题的先备知识有二叉树的基本结构、高度、宽度，以及二分法分而治之的概念。
>
>   [leetcode 655](https://leetcode.com/problems/print-binary-tree/)

```
样例:
Input:
     1
    /
   2
Output:
[["", "1", ""],
 ["2", "", ""]]
 
 Input:
     1
    / \
   2   3
    \
     4
Output:
[["", "", "", "1", "", "", ""],
 ["", "2", "", "", "", "3", ""],
 ["", "", "4", "", "", "", ""]]
```

```java
public class PrintBinaryTree {
    public static List<List<String>> printTree(Tree tree) {
        int height = getHeight(tree);
        int width = (int) Math.pow(2, height) - 1;

        List<List<String>> table = new ArrayList<>(height);
        for (int i = 0; i < height; i++) {
            List<String> tmp = new ArrayList<>(width);
            for (int j = 0; j < width; j++) {
                tmp.add("");
            }
            table.add(tmp);
        }

        fill(table, tree, 0, 0, width);
        return table;
    }
  
    private static int getHeight(TreeNode tree) {
        return Math.max(tree.left != null ? getHeight(tree.left) : 0,
                tree.right != null ? getHeight(tree.right) : 0) + 1;
    }

    private static void fill(List<List<String>>  table, Tree tree, int height, int left, int right) {
        if (tree == null) {
            return;
        }
        int mid = left + (right - left) / 2;
        if (left < right) {
            table.get(height).set(mid, String.valueOf(tree.val));
        } else { // left == right 的情况
            table.get(height).set(left, "" + tree.val);
        }
        fill(table, tree.left, height + 1, left, mid - 1);
        fill(table, tree.right, height + 1, mid + 1, right);
    }

    // static class in Java ?
    public static Tree getSample() {
        Tree root = new Tree(1, null, null);
        Tree child0 = new Tree(2, null, null);
        Tree child1= new Tree(3, null, null);
        Tree child2 = new Tree(4, null, null);
        root.left = child0;
        root.right = child1;
        root.left.right = child2;
        return root;
    }

    public static class Tree {
        public Tree left;
        public Tree right;
        public int val;

        public Tree(int val, Tree left, Tree right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }
  
    public static void main(String[] args) {
        Tree root = getSample();
        List<List<String>> result = printBinaryTree(root);
        for (List<String> vals : result) {
            for (String val : vals) {
                System.out.print(val + " ");
            }
            System.out.println("");
        }
    }
}
```

### 二叉树特性

```
     1
    / \
   2   3
    \
     4
```



-   包含n (n>0) 个元素的二叉树的边树为 n-1

-   若二叉树的高度为 h (h >= 0)，则该二叉树至少有 h 个元素，至多有 2^h - 1个元素

-   包含n个元素的二叉树高度最大为 n，最小为 log(n-1)

-   设完全二叉树中元素的序号为i，且 1 <= i <= n ，则以下规则成立

    -   当 i = 1 时，该元素为二叉树的根。若i>1则该元素的父节点的编号为 i/2
    -   当 2i>n 时，该元素无左孩子。否则其左孩子的编号为 2i
    -   若 2i+1 > n，该元素无右孩子。否则其右孩子的编号为 2i+1

-   二叉树中缺少的元素较少时推荐使用数组来表示

    二叉树的存储结构：(1) 顺序存储结构；(2) 链式存储结构

### 二叉搜索树

>   Binary Search Tree



### 平衡二叉树

>   Self-balancing binary search tree



### 红黑树

>   Red Black Tree



